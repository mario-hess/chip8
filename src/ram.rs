pub struct Ram {
    data: [u8; 4096],
}

impl Ram {
    pub fn new() -> Self {
        let mut data = [0; 4096];

        // Programs may also refer to a group of sprites representing the hexadecimal
        // digits 0 through F. These sprites are 5 bytes long, or 8x5 pixels.
        // The data should be stored in the interpreter area of Chip-8 memory (0x000 to 0x1FF).
        let sprites: [[u8; 5]; 16] = [
            [0xF0, 0x90, 0x90, 0x90, 0xF0],
            [0x20, 0x60, 0x20, 0x20, 0x70],
            [0xF0, 0x10, 0xF0, 0x80, 0xF0],
            [0xF0, 0x10, 0xF0, 0x10, 0xF0],
            [0x90, 0x90, 0xF0, 0x10, 0x10],
            [0xF0, 0x80, 0xF0, 0x10, 0xF0],
            [0xF0, 0x80, 0xF0, 0x90, 0xF0],
            [0xF0, 0x10, 0x20, 0x40, 0x40],
            [0xF0, 0x90, 0xF0, 0x90, 0xF0],
            [0xF0, 0x90, 0xF0, 0x10, 0xF0],
            [0xF0, 0x90, 0xF0, 0x90, 0x90],
            [0xE0, 0x90, 0xE0, 0x90, 0xE0],
            [0xF0, 0x80, 0x80, 0x80, 0xF0],
            [0xE0, 0x90, 0x90, 0x90, 0xE0],
            [0xF0, 0x80, 0xF0, 0x80, 0xF0],
            [0xF0, 0x80, 0xF0, 0x80, 0x80],
        ];

        for (index, value) in sprites.iter().flatten().enumerate() {
            data[index] = *value;
        }

        Self { data }
    }

    pub fn write_byte(&mut self, address: u16, value: u8) {
        self.data[address as usize] = value;
    }

    pub fn read_byte(&self, address: u16) -> u8 {
        self.data[address as usize]
    }

    pub fn get_instruction(&self, address: u16) -> u16 {
        (self.read_byte(address) as u16) << 8 | self.read_byte(address + 1) as u16
    }
}
